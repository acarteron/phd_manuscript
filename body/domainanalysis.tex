\chapter{Analyse de domaine}
\begin{preamble}
Dans ce chapitre nous analysons un large éventail de services d'assistance domiciliaire dédié aux personnes âgées, en considérant la variété des besoins des intervenants, pour identifier les concepts clés et les opérations spécifiques pour le traitement de la sensibilité au contexte. Reposant sur cette analyse, nous proposons un langage dédié et sensible au contexte avec son architecture logicielle. Cette approche permet de mettre en synergie les intervenants d'une maison sensible au contexte, en leur fournissant une approche unifiée pour concevoir et développer des services.
\end{preamble}
\chpsummary{Contributions}
{
{\em Domain analysis} We provide an analysis of context-aware processing layers in the domain of aging in place. From this analysis, we identify key concepts and operations specific to context-aware processing.;
{\em Domain-specific language} We introduce a language, specific to developing context-aware services, providing high-level abstractions and notations. 
Underlying this language is a data-centric and data-driven paradigm that allows services from a range of stakeholders to uniformly process heterogeneous sources of sensed data.;
%\myparagraph{Compiler} We have implemented a compiler for our DSL that maps high-level rules into low-level requests, crunched by an event-processing engine.
{\em Validation} We applied our approach to re-implement 55 services, ranging over all the stakeholders of an assisted living platform dedicated to aging in place. The resulting services are expressed at a high level and are effective in performing the tasks of the stakeholders.
}


La notion de {\em contexte} est fondamentales dans les champ de l'informatique ubiquitaire et englobe de beaucoup de dimensions, le monde physique, un individu, ses activités, les technologies déployées, etc~\cite{bauer2012comparison}.
% This wide range of dimensions is reflected in the host of application areas that leverages context awareness, spanning infrastructures ({\em e.g.,} railways), premises ({\em e.g.,} buildings), and health ({\em e.g.,} physiological status). 
Une attention particulière de la recherche a été portée sur le {\em domicile} ({\em e.g.,}~\cite{cook2013casas,feminella2014piloteur}). Ce périmètre implique beaucoup de dimensions contextuelles, notamment les interactions physiques avec l'environnement ({\em i.e.,} capteurs), les interactions numériques avec l'environnement de l'utilisateur ({\em i.e.,} email, agenda), l'état des nombreux composants de l'infrastructure de l'informatique ubiquitaire (matériel, logiciel et réseau), les préoccupations relatives aux applications ({\em i.e.,} détection d'activité). Concernant la population générale, le défit récurant est d;identifier de quels services ont besoins les utilisateurs~\cite{brush2011home}, et plus généralement, de développer de méthodes pour recueillir et analyser ces besoins~\cite{coutaz2010disqo}.

Toutefois, dans le domaine du maintien à domicile de personne âgées, un tel environnement peut fournir
des services d’assistance pour pallier les pertes cognitives dues au vieillissement et assurer une vie
indépendante({\em e.g.,} ~\cite{rashidi2013survey}). Ces services sont principalement: (1) détecter et rappeler les activités du quotidien ({\em e.g.,} préparation de repas, toilette, se coucher) pour maintenir le status fonctionnel de l'utilisateur~\cite{caroux2014verification} et (2) surveiller les situations potentiellement dangereuses ({\em e.g.,} cuisinière, porte d'entrée) pour garantir la sécurité de l'utilisateur~\cite{rashidi2013survey}. 
Parce qu’elle implique plusieurs disciplines, une maison équipée d’informatique ubiquitaire et
dédiée au maintien à domicile de personnes âgées demande l’implication d’une variété d’intervenants, tant pour concevoir et développer des services d’assistance, que pour déployer et maintenir l’infrastructure sous-jacente. De ce fait parmi ces intervenants on retrouve les personnes âgées elle-même, les aidants, les expets en vieillissement, les professionnels de santé, les développeurs d'applications ainsi que les techniciens de maintenance. 
Cette grande diversité d’intervenants correspond à une diversité
de contextes : les services de chaque intervenant repose sur des contextes spécifiques (état des
capteurs pour la maintenance, utilisation du frigidaire pour l’assistance à domicile). Ces différents
contextes sont généralement étudiés séparément, en silo. Typiquement, chaque intervenant développe sa propre approche, pour extraire ses informations contextuelles, empêchant toute synergie.

Nous avons analysé un large éventail de services d'assistance domiciliaire dédié aux personnes âgées, en considérant la variété des besoins des intervenants. Ces services sont installés sur une plate-forme d'assistance domiciliaire déployée chez 129 personnes âgées vivant seules et âgées de 82 ans en moyenne~\cite{consel2017homeassist}. 
Cette analyse a permis d'identifier les concepts commun et les variations
entre différentes couches de services déployés et utilisés au quotidien,
pour en extraire des concepts clés et des opérations spécifiques aux
traitements sensibles au contexte.

%\subsection*{Our Approach}

Nous basant sur cette analyse, nous proposons un langage de spécifique, sensible au contexte, appelé Maloya et son architecture logiciel, qui fournie un cadre de conception et les outils pour concevoir et développer des services domiciliaires. Pour unifier les source hétérogènes de données, de composants matériels aux composant logiciels, notre approche promeut un paradigme ``centré données'' et ``orienté données''. Notre approche est {\em centrée données} pour fournir une vue canonique des données mesurée à l'ensemble des services, couvrant les services de maintenance requérant l'état bas niveau des capteurs, jusqu'aux services spécifiques aux aidants nécessitants des mesures d'activités de haut niveau. Notre approche est {\em orientée données} avec des services définis en terme de règles traitant des évènements et des états.


To unify the way services are developed, our approach introduces abstractions and notations that are specific to context-aware processing. The resulting {\em domain-specific language} (DSL) covers the needs of the stakeholders and provides an abstraction layer over underlying, well-established concepts and technologies, such as Allen's algebra to express sequences of interactions~\cite{Allen} and complex-event-processing engines to efficiently process the rules generated from DSL services ({\em e.g.,}~\cite{Cugola:2012:PFI:2187671.2187677}). Furthermore, we envision that our language can serve as a high-level stepping stone to introduce end-user programming languages for stakeholders with no computer-programming background.

To validate our approach, we have re-implemented 55 services ranging over all the stakeholders of the assisted living platform under study. These new services were deployed and successfully tested for their effectiveness in performing the specific tasks of the stakeholders: detection of daily activities, detection of user risks, sensor failure, {\em etc.}

% \subsection*{Contributions}
% To summarize, this paper makes the following contributions.

% \myparagraph {Domain analysis} We provide an analysis of context-aware processing layers in the domain of aging in place. From this analysis, we identify key concepts and operations specific to context-aware processing.

% \myparagraph {Domain-specific language} We introduce a language, specific to developing context-aware services, providing high-level abstractions and notations. 
% Underlying this language is a data-centric and data-driven paradigm that allows services from a range of stakeholders to uniformly process heterogeneous sources of sensed data.

% \myparagraph{Compiler} We have implemented a compiler for our DSL that maps high-level rules into low-level requests, crunched by an event-processing engine.

% \myparagraph {Validation} We applied our approach to re-implement 55 services, ranging over all the stakeholders of an assisted living platform dedicated to aging in place. The resulting services are expressed at a high level and are effective in performing the tasks of the stakeholders.





\section{Domain analysis}
La sensibilité au contexte dans le maintien à domicile des personnes âgées reste jeune et le chemin vers l'adoption est encore en étude~\cite{kaye2017making}. La littérature comporte encore peu d'articles concernant le déploiement de solutions d'assistances dans le domicile réel d'utilisateurs ({\em e.g.,} \cite{kaye2011intelligent}). Heureusement, nous avons pu faire levier sur le projet DomAssist pour conduire notre analyse du domaine sur les domiciles sensibles au contexte pour le maintien à domicile des personnes âgées.

\subsection{DomAssist: Un domicile sensible au contexte pour le maintien à domicile des personnes âgées}

DomAssist est une plate-forme d'assistance qui fournit un catalogue d'applications d'assistance, pour le support des activités du quotidien, la sécurité de l'utilisateur et ses interactions sociales~\cite{consel2017homeassist}. DomAssist est déployée les domiciles de 129 personnes vivants seule âgées de 82 ans en moyenne, pour une durée de 12 mois.

DomAssist est un parfait cas d'étude sur lequel construire une approche unifier pour développer des services pour domiciles sensibles au contexte dédié au maintien a domicile. Il rassemble tout les besoins pour viser notre but: (1) il est déployé dans des environnements réels; (2) il supporte le maintien a domicile de personnes âgées avec des utilisateur fragiles et des besoins immédiats; (3) l'étude conduite est suffisamment longue pour que les problèmes de maintenances et d'évolution aient à être traité rigoureusement; (4) la plate-forme est déployée à une échelle suffisamment large pour que l'administration des domiciles sensibles au contexte ait besoin d'être supporté par des services; (5) les services existant reflètent un large éventail de besoins exprimés par les intervenants, couvrant les utilisateurs, les aidants, les ergothérapeutes, les psychologues, les experts en facteurs humains, les techniciens d'installation et de maintenance, et les informaticiens.

Décrivons maintenant la plate-forme pour délimiter la courverture des services sensibles au contexte. DomAssist se compose d'une architecture client-serveur, pour laquelle le serveur instancie autant de machine virtuelle qu'il y a de domicile sensible au contexte. Chaque machine virtuelle exécute les services d'assistance selectionnés par l'utilisateur et ses aidants. Ces services d'assistance sont alimentés par des données envoyées par Internet via une passerelle déployée dans le domicile. Cette passerelle rassemble les informations en provenance des capteurs placés dans des endroits stratégiques pour surveiller les activités. 
 As well, the gateway channels actions from the services to the home's actuators. In the HomeAssist field study, a typical home consists of 4 contact sensors (entrance door, drawers, cabinets, {\em etc.}), 6 motion detectors (entrance area, kitchen, bathroom, {\em etc.}), and 2 smart plugs, which measure the electricity consumption and turn on/off a connected appliance (microwave, light path, coffeemaker, {\em etc.}). The number and type of devices can vary depending on the configuration of the home and the activities to be monitored. Finally, the home is equipped with a stationary tablet, placed at a central location in the home and always connected to a power outlet. This tablet is dedicated to interacting with the user via notifications emitted by assistive applications, which need to alert the user of a given situation ({\em e.g.} unattended entrance door left open)~\cite{consel2015unifying}.

% Let us now illustrate the diversity of issues addressed by HomeAssist with a set of existing scenarios dedicated to support aging in place.




%**********************************************
\subsection{Scénarios pour le maintien à domicile}\label{domain:scenario}
Nous présentons maintenant quatre scénarios illustrant la variété d'intervenants et de préoccupations nécessaires au support du maintien à domicile de personnes âgées à l'aide d'une maison sensible au contexte (voir Figure~\ref{scenario-fig}). Le premier scénario adresse la sécurité de l'utilisateur. Ce scénario surveille la porte d'entrée pour s'assurer qu'elle ne reste pas ouverte trop longtemps sans être surveillée. Le deuxième scénario, se rapporte au besoin de l'aidant en terme de surveillance des activités du quotidien, en particulier, les routines de préparation de repas. Les deux dernier scénarios concernent des besoins exprimés par les techniciens pour garder les domiciles sensible au contexte opérationnels. Le premier scénario de maintenance détecte l'utilisation d'un placard sans que celle-ci soit recouverte par la détection d'une présence. Le second scénario de maintenance détecte quand un capteur échoue à communiquer; cette situation se produit lorsque le capteur n'a plus de batterie ou dysfonctionne.

\begin{figure*}[t]
\begin{tabular}{| l | l | l | p{7cm} |} \hline
{\bf Stakeholder} & {\bf Domain} & {\bf Name} & {\bf Description} \\ \hline \hline
Older adult& Safety & Door Alert & Entrance door \uline{is open} and  \uline{is unattended} \dotuline{for 5 minutes} \\ \hline
Caregiver & \begin{tabular}{ll} Daily \\ Activities \end{tabular} 
       & \begin{tabular}{ll} Reheating \\ A Frozen Meal\end{tabular} 
          & Freezer \dashuline{gets used} and stove \dashuline{gets turned on} \dotuline{within 10 minutes} or Freezer \dashuline{gets used} during stove \uline{is on},
during \uline{lunch time} (or dinner time) \\ \hline
\begin{tabular}{ll} Home \\Technician \end{tabular}
               & Maintenance & \begin{tabular}{ll} Presence \\ Dependency\end{tabular} 
                  & Whenever the cupboard \dashuline{gets opened} in the kitchen, a presence in the kitchen \uline{is true} \\ \hline
\begin{tabular}{ll} Home \\Technician \end{tabular}
   & Maintenance 
        & \begin{tabular}{ll} Communication \\ Failure \end{tabular} 
             & A sensor \uline{fails to communicate} \dotuline{for 24 hours} and its status does not \dashuline{get updated} \\ \hline
\end{tabular}
\caption{Example scenarios for assistive services}
\label{scenario-fig}
\end{figure*}

Ces scénario offre un apperçu sur les type de services sensibles au contexte nécessaire pour supporter le maintien à domicile de personnes âgées. Certains services tels que ``Door Alert'', peuvent convenir à la plupart des utilisateur. En revanche d'autres services, typiquement, les services concernant les activités du quotidien nécessite un certain degrée de personnalisation pour être efficace. Ceci est illustré par l'activité de préparation de repas et le scénario ``Reheating a Frozen Meal''.

De la même manière, ``Communication Failure'' peut s'appliquer à n'importe quel domicile sensible au contexte, alors que ``Presence Dependency'' demande d'instancier les règles en fonction de la localisation des capteurs. 

\subsection{Analyse de commonalités et variabilités}
Pour conduire notre analyse du domaine, nous avons examiné un éventail de services offert par DomAssist pour identifier leurs commonalités et leurs variabilités. Ces services sont développés en Java en utilisant une méthodologie de conception outillée~\cite{bertran2014diasuite,cassou2012toward}.

We now present the outcomes of this analysis that take the form of high-level, domain-specific concepts. These concepts will pave the way to our domain-specific approach presented in the next section.

\myparagraph{Commonalités} Tous les services se réfèrent à une notion d'{\em environnement} à partir duquel effectuer les mesures. Ces mesures englobent les interactions à la fois dans l'environnement physique ({\em e.g.,} un mouvement détecté) et dans l'environnement numérique ({\em e.g.,} un rappel d'évènement délivré par un agenda). De plus, nous avons identifié deux concepts complémentaires associé à l'environnement: évènements et états. D'un côté, un {\em évènement} définie une mesure d'environnement qui change ({\em e.g.,} une porte devient ouverte/fermée) -- les évènements sont soulignés avec des pointillés dans les scénarios de la Figure~\ref{scenario-fig}. D'un autre côté, un {\em état} rend un évènements persistant à travers le temps ({\em e.g.,} la porte {\em est} ouverte) -- les états sous soulignés avec une ligne pleine dans la Figure~\ref{scenario-fig}. Une fois ces concepts identifiés, nous définissons les façons spécifiques de les combiner, exposant les commonalités de {\em composition}. Spécifiquement, la combinaison de mesures d'environnement peut définir un {\em ordre} dans lequel les interaction doivent arriver et leur {\em durée} -- ces contraintes sont soulignées avec des points dans la Figure~\ref{scenario-fig}.

Étudions plus en détail ces points communs en examinant leur spectre de variabilité.

\myparagraph{Variabilités} Les mesures environnementales peuvent être réalisées par une variété d'entités, matérielles ({\em e.g.,} capteurs), logicielles ({\em e.g.,} agenda), locales ({\em e.g.,} porte), distante ({\em e.g.,} nouvel email), {\em etc.} Le niveau d'abstraction énormément selon les mesures environnementales. Par exemple, un évènement peut être produit par un capteur, sitôt qu'un mouvement est détecté dans une pièce. Parallèlement, un capteur peut détecter l'état d'une pièce occupée, en excluant les transferts d'une pièce à l'autre.

En ce qui concerne la composition, plusieurs contraintes d'ordre ont été observées en ce qui concerne les interactions. Une interaction peut en {\em précéder} une autre, une interaction arrive {\em durant} une autre, et une interaction en {\em chevauche} une autre. Cependant toutes ces contraintes ne sont pas applicables à tout types d'interactions ({i.e.,} évènements et états). Par exemple, seulement deux évènements peuvent se chevaucher, alors que les évènements ne peuvent pas. 
%Indeed, in practical scenarios, events are viewed as occurring sequentially, not simultaneously.

\section{Un langage spécifique dédié aux services sensibles au contextes}\label{sec:dsl}

In this section, we introduce our DSL for developing context-aware services. This DSL is dedicated to describing contexts in terms of states and events, and operators to combine them. Figure~\ref{fig:operators}  presents the syntax of our DSL, as well as its informal semantics. Each construct of the language is presented on the left-hand side; its corresponding graphical representation is displayed on the right-hand side. This graphical representation visualizes events and states, and how operators combine them. A state is represented as a rectangle-shaped signal, visualizing the starting and ending points of the occurrence of an event. An event is represented as a spike signal, with merged starting and ending points. Underneath each DSL construct is its translation into a core DSL, which can be viewed as an abstract syntax.

Nous présentons également les étapes principales de notre approche spécifique au domaine pour développer des services sensibles au contexte dédié au maintien à domicile des personnes âgées. Cette approche est décrite en Figure~\ref{fig:functionalarchi}.

\begin{figure}[h]
\centering
  \includegraphics[scale=0.2]{gfx/approach}
\caption{Overall view of our domain-specific approach}
\label{fig:functionalarchi}
\end{figure}

\subsubsection{Définition du service}
La première étape est initiée avec les intervenants qui expriment les scénarios de services, comme illustré plus tôt. Ces scénarios sont directement écrit dans notre langage dédié par l'intervenant, si ils ont le bagage nécessaire ou par un développeur de services.

\subsubsection{Compilation du service}
Les services de haut niveau sont compilés dans des règles de plus bas niveau dans un langage de traitement d'évènement. Ces règles rendent explicite les concepts spécifiques au domaine, tels que les états qui sont compilés vers des combinaisons d'évènements et les opérations relatives.

\subsubsection{Exécution du service}
Pour être déployées, les règles sont ajoutés à un moteur de traitement d'évènement complexe (CEP). Notre moteur d'exécution de règle est basé sur Esper, un CEP open-source développé par EsperTech\footnote{http://www.espertech.com/esper/}. Esper propose des interface Java et C\# pour développer des programmes événementiels. Nous avons choisis Esper parce qu'il s'agit d'un moteur CRP populaire utilisé à la fois dans l'industrie et dans la recherche. Esper fournie un langage specifique et déclaratif pour le traitement d'évènement complexes, appelé EPL (pour Event Processing Language). EPL permet de décrire des motifs d'évènements à identifier dans un flux d'évènements temps réel, en utilisant des opérateurs pour ordonner les évènnements, des contraintes temporelles, {\em etc.} Esper ne permet pas de manipuler le concept d'état; il permet uniquement de traiter des évènements et nécessite donc quelques manipulations pour gérer un état. Dans notre implémentation, nous utilisons Esper avec règles EPL, compilées depuis des règles écrites en langage Maloya, et un flux d'évènement issue de domiciles sensibles au contexte, formattés en une forme canonique.

\subsubsection{Forme canonique}
La forme canonique de données produites par un domiciles sensibles au contexte permet de faire les traitement de façon uniforme, indépendemment de leur format hétérogène original. Dans notre implémetation, la forme canonique de données, appelée {\em StreamEvent}, est introduite comme couche d'abstraction sur le flux d'évènements de données. Dans cette représentation, chaque évènement est un 4-tuple du type d'évènements, sa localisation, sa valeur, et l'horodatage de son occurrence.


\input{body/extern/operators} 

\subsection{Events and States}
In our DSL, testing an event or a state is expressed as follows: for an event, {\ttfamily p {\em becomes} v} ; for a state, {\ttfamily p {\em is} v}. Where, in both cases, {\ttfamily p} is a sensor name (hardware or software) and {\ttfamily v} is a value in the range of the sensor.  The event {\ttfamily p {\em becomes} v} occurs when the sensor {\ttfamily p} signals a value {\ttfamily v}, if its previous value was different. The state {\ttfamily p {\em is} v} starts precisely when the event {\ttfamily p {\em becomes} v} occurs; it ends when the event {\ttfamily p {\em becomes} v'} occurs, where {\ttfamily v'} $\neq$ {\ttfamily v}. We view the period during which a state holds as the {\em time interval} of a state. This notion is generalized for events by viewing them as defining a zero-length time interval. The notion of time interval is used to define operators and their semantics.
% Note that every sensor {\tt p} is assumed to have an initial value {\tt v$_0$}.

A {\em rule} in our DSL consists of an operator applied to states and/or events. All operators return an event.
More precisely, an operator yields a success event when the context described by the application of an operator is detected. 
%A rule yields a success event, or no event if the context described is not detected. 
Because operators return events, operators taking an event as a given argument can call a nested operator instead.
On the other hand, operators taking a state as a given argument cannot call a nested operator instead.
Thus, the nesting of operators is not arbitrary; it follows the results of our domain analysis. Operators are further discussed next.

\subsection{Operators}
Our operators, listed in Figure~\ref{fig:operators}, are based on the operators in Allen's time interval algebra~\cite{Allen}, viewing states and events as time intervals, as explained earlier. Specifically, Allen's operators model all possible relations between two time intervals, such as {\em preceding}, {\em during}, or {\em overlapping}. However, in our domain, since a context-aware home produces in principles an infinite stream of events, it may contain several occurrences of the same event. For example, an event such as lunch activity may occur many times in the stream of events produced by a home; typically, every day. Thus, a rule checking whether the lunch activity is performed during lunch time is tested repeatedly: for each occurrence of the lunch time slot. To account for this situation, we generalized Allen's operators between two intervals to account for their multiple occurrences. Allen's operators take non-empty time intervals; we generalized them to accept events, when appropriate.

%  Also, for each operator, we defined variants taking an optional time constraint. Although, the semantics of this time constraint depends on the operator, conceptually it amounts to refine the relationship tested by an operator on two time intervals. This is properly introduced 

% The result of all our operators are the events marking a successful recognition of the corresponding relationship on two interval instances.
% We also generalized Allen's relations to accept events as some operands, seen as time intervals of length zero.

Let us now review in detail the operators used in the examples of this paper. In the rule {\ttfamily e$_1$ {\bf precedes} e$_2$}, the operator yields success every time the occurrence of event {\ttfamily e$_1$} {\em immediately} precedes the occurrence of event {\ttfamily e$_2$}. This means that there must be no other occurrence of either {\ttfamily e$_1$} or {\ttfamily e$_2$} in between. To cover existing scenarios, we need to expand the expressiveness of this operator (and others) with optional time constraints. More precisely, we introduce two variants of {\ttfamily \bf precedes}: {\ttfamily e$_1$ {\bf precedes} e$_2$ {\bf within/by} t}. The time constraint is defined by the parameter {\ttfamily t}. These variants specify an upper/lower bound on the time between the occurrences of its event operands.

% The success event is produced precisely when the relationship is detected, that is, when the matching E2 instance occurs.

The rule {\ttfamily e {\bf during} s} succeeds every time event {\ttfamily e} occurs during state {\ttfamily s}. There are no time-constrained versions of this operator.

The rule {\ttfamily s$_1$ {\bf overlapping} s$_2$} succeeds every time state {\ttfamily s$_1$} overlaps with state {\ttfamily s$_2$}.  This means that state {\ttfamily s$_1$} starts before the beginning of state {\ttfamily s$_2$}, and ends during {\ttfamily s$_2$}, as shown in the Figure~\ref{fig:operators}.  The time-constrained versions define an upper/lower bound on the overlapping time of the occurrence of these states.

The rule {\ttfamily e {\bf occurs while} s} is similar to the rule {\ttfamily e {\bf during} s}, but succeeds only for the first occurrence of event {\ttfamily e} during state {\ttfamily s}. A variant of the previous rule is {\ttfamily s$_1$ {\bf occurs while} s$_2$}. In this case, the rule succeeds the first time state {\ttfamily s$_1$} superposes at least partially with {\ttfamily s$_2$}. The time-constrained versions put an upper/lower time bound on the superposition of the states.

Even though Allen's operators express a range of situations, they do not cover all the needs revealed by our domain analysis; more operators are required. In particular, a disjunction of events is needed to enable alternative contexts to be expressed. A disjunctive rule is of the form {\ttfamily \{e$_1$ {\bf or} \ldots~ {\bf or}~ e$_n$\}}; it succeeds whenever any {\ttfamily e$_i$} occurs. Dually, we introduced a conjunction rule of the form {\ttfamily \{e$_1$ {\bf and} \ldots~ {\bf and} e$_n$\}}. This rule succeeds when every {\ttfamily e$_i$} occurred. 
% \cc{Je propose de dropper:
% The variant ``\{E1, ... En, S1\} All S2'' \nv{check syntax!}  additionally requires that an instance of state S1 superposes at least partially with the matching instance of state S2.}  
% \cc{There are no time-constrained variants of the All operator. \nv{Is it so?}  \nv{Delete the defs in the figure in terms of Occurs, as there is no And operator!}  \nv{Add the textual form of  Or, All, All} \nv{Delete the braces in the signature of All, All}}

%As can be seen in Figure \ref{fig:operators}, every operator of our DSL has a textual, usually infix. \cc{Why is this useful information?, syntax which is used in the DSL and a term syntax which is used in our compiler, called the ``core DSL''.}

Let us now illustrate the use of our DSL operators by writing the rule for the ``Lunch Reheat'' activity, described earlier (Section~\ref{domain:scenario}). 
%It is used as a running example throughout this section to further introduce our DSL and its implementation.

\footnotesize
\begin{alltt}
{\bf \{} ( Freezer {\itshape becomes} open {\bf precedes} 
    {\bf within} 10 minutes Stove {\itshape becomes} on )
  {\bf or}
  ( Freezer {\itshape becomes} open {\bf occurs while} Stove{\itshape is} on )
{\bf \} occurs while} LunchTime
\end{alltt}
\normalsize

Note how this specification concisely encodes two scenario variants: (1) taking a meal from the freezer, and then turning on the stove;
(2) taking a meal from the freezer to put it in the stove, which is already running.

\subsection{Compilation}\label{dsl:compilation}
Compilation is done in three main steps. The first step translates the text of DSL rules into the core DSL; this translation is defined as a one-to-one correspondence. 
% As shown in Figure~\ref{fig:operators}, there is a one-to-one correspondence between our DSL and core DSL. 
For instance, the core DSL form of the operator {\ttfamily e {\bf during} s} is $During(e,s)$. The translation of our running example into core DSL is as follows.

%\myparagraph{Core DSL}
%Operators on states and events
\mathleft
\footnotesize
\begin{equation*}
  \begin{split}
&Occurs(Or(\\
&\quad\quad\quad\quad Precedes\_less(10min)(freezer => open, stove => on), \\
&\quad\quad\quad\quad Occurs(freezer => open, stove = on)), \\
&\quad\quad lunchTime)
  \end{split}
\end{equation*}
\normalsize
\noindent
Where ``{\em =$>$}'' denotes an event that occurs and ``{\em =}'' denotes a state that holds.

The next compilation step consists of generating EPL pseudo-code. This pseudo-code uses only valid EPL operators, but does not yet instantiate the attributes of each event; this is done subsequently.  This step involves several transformations.  Firstly, as EPL does not support the notion of state, each state in a rule is translated into the sequence of corresponding events that mark the beginning and the end of the state, ordered by standard EPL operators. For instance, the state of the stove being on is translated in an EPL sequence of the stove being turned on, followed by any event of interest but not the stove being turned off. Hence, the operator ``{\em Occurs(\dots, stove = on)}'' is translated in EPL as 
\begin{quote} {\em stove $\Rightarrow$ on $\rightarrow$ \dots\ and\ not\ (stove $\Rightarrow$ off)} \end{quote}
\noindent 
using the EPL operators ``{\em and}'', ``{\em or}'' and ``$\rightarrow$'', which means {\em followed by}.  Also in this compilation phase, time constraints in the rules are translated by explicit uses of the ``{\em timer:within}'' construct in EPL for enforcing upper time bounds, and explicit uses of ``{\em timer:interval}'' EPL construct for enforcing lower time bounds.  The result of this phase is the following EPL pseudo-code:

% \myparagraph{EPL pseudo-code}
% sequence of events resulting on operator compilation
\footnotesize
\begin{equation*}
  \begin{split}
&lunchTime\Rightarrow begin \rightarrow\\
&\quad\quad ( ( freezer\Rightarrow open \rightarrow  stove\Rightarrow on\ and\\ 
&\quad\quad not\ ( freezer\Rightarrow open )\ where\ timer:within(10min) )\\ 
&\quad\quad or\\  
&\quad\quad ( stove\Rightarrow on \rightarrow  ( freezer\Rightarrow open )\ and\ not\ ( stove\Rightarrow off ) ) )  \\
&and\ not\ ( lunchTime\Rightarrow end )
  \end{split}
\end{equation*}
\normalsize

The final step is to obtain the EPL Esper form from the EPL pseudo-code, by completely instantiating the event attributes as necessary in the stream of canonical events ({\em i.e.,} in StreamEvent form). To do so, we use a static table giving the attributes of each sensor in a given home:

\begin{figure}[h]
\begin{footnotesize}
\begin{Verbatim}
"freezer":{
	"location": "Kitchen",
	"kind": "Freezer",
	"values": ["open", "close"]
}
\end{Verbatim}
\end{footnotesize}
\end{figure}

Moreover, this step binds all events in an EPL formula as originating from the same home (as can be seen in the EPL constraint ``{\ttfamily user=$X$.user}'' below).  Also, this step introduces ``{\em every}'' and ``{\em every-distinct}'' EPL constructs to deal with multiple occurrences of an event. As a result of these transformations, we obtain the final EPL Esper rule that is executed by the Esper engine:

% \myparagraph{EPL Esper}
% data used to recognize events.
%\begin{figure}[h!]
\begin{footnotesize}
%[numbers=left,xleftmargin=0mm]
\begin{lstlisting} [frame=single]
select Cal_L_b,Fre_K_o,Sto_K_o from pattern [ 
  every Cal_L_b=StreamEvent(role.location='Lunch',
                            role.type='Calendar',
                            status!='end') -> 
    ((every-distinct(timestamp)
      Fre_K_o=StreamEvent(role.location='Kitchen',
                          role.type='Freezer',
                          status='open',
                          user=Cal_L_b.user) -> 
        Sto_K_o=StreamEvent(role.location='Kitchen',
                            role.type='Stove',
                            status='on',
                            user=Cal_L_b.user) 
        where timer:within(10min)
        and not (StreamEvent(role.location='Kitchen',
                              role.type='Freezer',
                              status='open',
                              user=Cal_L_b.user))) 
   or(every-distinct(timestamp)
      Sto_K_o=StreamEvent(role.location='Kitchen',
                          role.type='Stove',
                          status='on',
                          user=Cal_L_b.user) -> 
      (Fre_K_o=StreamEvent(role.location='Kitchen',
                           role.type='Freezer',
                           status='open',
                            user=Cal_L_b.user)) 
       and not (StreamEvent(role.location='Kitchen',
                            role.type='Stove',
                            status='off',
                            user=Cal_L_b.user))) 
    ) and not (StreamEvent(role.location='Lunch',
                           role.type='Calendar',
                           status='end',
                           user=Cal_L_b.user)) ]
\end{lstlisting}
%\end{figure}
\end{footnotesize}

Note that, even though these transformation steps may seem straightforward, there are several subtleties involved, such as the complex operator compositions, which require introducing new stream variables (``named windows'' in EPL). The details of our compiler scheme are outside the scope of this paper, and will be described elsewhere.

\section{Validation}\label{sec:validation}
This section presents the validation of our approach on the HomeAssist platform.  The expressiveness of our DSL is validated by re-defining existing services in it. The correctness of our compiler is validated by comparing the results of executing the compiled rules with the results of existing services deployed in the platform. Finally, the efficiency of our DSL is validated by measuring some performance figures of our running implementation.

\input{body/extern/appexampletab}

\subsection{Expressiveness}\label{validation:expressiveness}
To validate the expressiveness of our DSL, we re-implemented 55 services already deployed in HomeAssist. These services are variations of 13 families of rules, which are listed in Figure~\ref{app_examples}. Variations within each family were required to match the specificities of older adults. For example, detecting daily activities, such as meal preparation and sleep/wa\-keup, have to be customized for each user with respect to sensing capabilities to detect environment interactions, time slots of activities, and time delays between sequences of interactions. For example, to prepare breakfast, an older adult may use an electric juicer and take a glass from a specific cupboard, whereas another one may turn on a kettle and opens the fridge to take the milk bottle.

Rewriting an extended range of services allowed us to validate that our DSL and its underlying concepts (event, state, Allen's operators) are expressive enough to cover realistic services in the domain of aging in place.


%\subsection{Compilation}\label{validation:compilation}
\subsection{Correctness}\label{validation:results}

We did not attempt to prove the correctness of our DSL compiler with respect to a formal semantics of its operators, although this work would be of interest. Instead, we empirically validated the correctness of the compiled services by a combination of visual code inspection and extensive testing. We performed manual inspection of all the intermediate forms described earlier (core DSL, EPL pseudo-code, Esper EPL) to ensure that they remain consistent with their original counterparts.

% More specifically, the services written in our DSL were compiled in several steps, as discussed in Section~\ref{dsl:compilation}: core DSL, EPL pseudo-code, Esper EPL.

Then, we validated the compiler output ({\em i.e.,} resulting EPL rules) in two phases. First, we tested the rules by executing them on log files from the HomeAssist project. These logs contain the timestamped events produced by all the sensors in the infrastructure, whether hardware or software. The results were checked automatically for correctness using Perl scripts, implementing the same service specifications. Note that these scripts are much simpler to write than the real applications, as they execute on log histories of sensed data, so they do not have to compute results online, and must not deal with the sensor infrastructure.

We repeatedly compared the results produced by the compiled DSL services and the scripted specifications on extended log histories. This iterative process allowed us to refine our compilation schemas until it produced the same results as the scripted specifications.

In a second phase, we connected the compiled DSL services to the online stream of events in the production platform for 9 users during 1 month, in parallel with the existing services written in Java. No difference was observed between the results of both systems (Java and DSL). Furthermore, this phase allowed us to assess the runtime performance of our approach, as discussed next.


\subsection{Performance}\label{validation:performance}
To validate the applicability of our DSL approach in practice, we measured in real conditions the performance of the EPL rules produced by our DSL compiler with respect to two indicators: the response time to online events, and the memory consumption of our execution engine. The rules were executed on the production server of the platform, which is a quad-core Intel(R) Xeon(R) E5-2407 v2 2.4 GHz CPU and 125GB RAM.

The response time of a rule indicates the time between the last event that should trigger a rule, and its effective triggering. A low response time means that the rule is sufficiently reactive for practical use. According to our measurements, the response time of all our rules were always less than a second. This order of magnitude is perfectly compatible with the kind of rules that are implemented in this platform for aging in place.

We also measured the memory consumption of our implementation to ensure that it can scale up to hundreds of users and to tens of implemented services. According to our measurements, the memory consumption was found to be 352MB on average, for 55 rules, processing data from 129 homes, and running 24/7 for one month. Encouraged by these figures, we further explored the applicability of our DSL by testing it on a smaller-scale architecture that is commonly used in pervasive computing environments, namely a Raspberry Pi 3 with a quad-core ARM Cortex-A53 1.2 GHz CPU and 1GB RAM. In this experiment, we ran the same 55 rules on the same 129 installations, online during 5 days. Memory consumption was found to be 173MB on average. 
The lower memory consumption on the Raspberry Pi is due to the fact that it is a 32-bit architecture.
These measurements indicate that our approach is both applicable for processing in the cloud 
and for embedded processing within the homes.

\section{Discussion}

Our DSL bridges the gap between high-level domain concepts and low-level mechanisms of event handling. As a consequence, it contributes to making rules more concise and  to simplify their development, by encapsulating details of event handling in a compiler.  Indeed, the original Java applications implementing HomeAssist services contain manually implemented timed automata, which recognize the sequences of events corresponding to each DSL rule.  Timing constraints are explicitly handled by using a timer service, producing timeout events that are inserted in the stream of events, produced by the sensor infrastructure.  In our DSL rules, these low-level details of state and time handling are included in the semantics of operators.  For instance, the role of explicit timers corresponds the parameters of our time-constrained operator variants. This lowers the efforts to write rules and to make them more predictable.

\subsection*{Limitations}

Our approach is a first step towards simplifying the development of context-aware applications in the domain of aging in place, and presents a number of limitations.

First of all, our DSL only is dedicated to recognizing contexts. It provides no constructs for performing actions on the environment. These must be currently programmed in a generic programming language. It would be useful to extend our domain analysis to also cover the control part of typical applications, and to derive domain-specific concepts and notations to perform actions.

As far as applications are concerned, we have designed and tested our DSL only on services in the domain of aging in place, which involves a specific set of composition operators. However, our DSL can express rich, arbitrarily nested combinations. It would be interesting to apply it to other domains of context-aware applications in the future.

Finally, our rules always return boolean values. However, context-aware information may sometimes be more general than strictly binary. For instance, a daily activity such as meal preparation might be detected in a more nuanced way as a probability between 0 and 1, to cope with some amount of deviations from the user's routine. Currently, in our DSL the different routine variations must be coded as different rules, which is not always practical. In the future, it would be interesting to consider extending our approach with operators returning non-boolean values.
% Such fuzzy detectors are sometimes used in the domain of aging in place.

\section{Conclusion}
%**********************************************
%**********************************************

We have proposed a new approach for developing context-aware services in a smart home, by
analyzing a range of existing data processing layers in the domain of aging in place. We have identified key concepts and operations specific to context-aware processing. Based on this analysis, we have introduced a context-aware, domain-specific language and its software architecture, which allow to put in synergy the stakeholders of a context-aware home by providing them with a unified approach to designing and developing services. Our approach offers context aware-specific abstractions and notations, within a data-centric and data-driven paradigm.
We have validated our approach by applying it to an assisted living platform for aging in place. In particular, we have used our domain-specific language to re-implement existing services of the assisted living platform. These services were deployed and successfully tested for their effectiveness in performing the specific tasks of the stakeholders: detection of daily activities, detection of user risks, sensor failure, {\em etc.}
