\section{Sémantique des opérateurs Maloya}
Dans la Section~\ref{sec:dsl:operator}, nous avons introduit les opérateurs et expliqué la façon dont ils traitent les informations contextuelles. Maintenant, nous décrivons leur compilation ainsi que leur sémantique formelle.

La compilation des opérateurs génère une séquence d'évènements en pseudo-code EPL selon la sémantique des opérateurs compilés.

\subsection*{Precedes(e$_1$,e$_2$)}
La séquence d'évènements résultant de la compilation de l'opérateur {\em Precedes} définit qu'un évènement {\tt e$_1$} doit être suivit par un évènement {\tt e$_2$}, en respectant la définition de l'opérateur Esper ``followed-by'', sans qu'un autre évènement {\tt e$_1$} ne se soit produit entre temps. La clause évery permet de tester la règle pour chaque occurrence de {\tt e$_1$}.
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$Precedes(e$_1$,e$_2$)$\rrbracket$=
  every WindowIfComplex($\llbracket$e$_1\rrbracket$) $\rightarrow$ 
    WindowIfComplex($\llbracket$e$_2\rrbracket$) 
      and not WindowIfComplex($\llbracket$e$_1\rrbracket$) 
\end{lstlisting}
%\(Precedes(E_1,E_2)(t)=(\exists t_1)(\forall t_2)(E_1(t_1)\wedge E_2(t)\wedge (t_1<t)\wedge ((t_1<t_2\leq t)\rightarrow \thicksim E_1(t_2)\vee \thicksim E_2(t_2)))\)\\

{\em Precedes} décrit la séquence de deux évènements E$_1$ et E$_2$. Noté $\operatorname{Precedes}(E_1,E_2)(t)$, il se produit lorsque E$_2$ se produit à condition qu'il ait été précédé de la dernière occurrence de E$_1$. Ceci implique que l'instant auquel E$_1$ se produit est inférieur à l'instant auquel E$_2$ se produit et qu'il n'existe pas de moment entre ces instants durant lequel il y a eu une autre occurrence de E$_1$ ou de E$_2$. Cet opérateur est formellement défini ainsi:
\begin{equation*}
\begin{split}
\operatorname{Precedes}(E_1,E_2)(t)=&(\exists t_1)(\forall t_2)(E_1(t_1)\wedge\\
&\qquad\qquad \thicksim E_1(t) \wedge\\
&\qquad\qquad E_2(t)\wedge (t_1<t)\wedge\\
&\qquad\qquad ((t_1<t_2<t)\rightarrow \thicksim (E_1(t_2)\vee E_2(t_2))))
\end{split}
\end{equation*}


\subsection*{During(e,s)}
La compilation de l'opérateur {\em During} décrit toutes les occurrence de l'évènement correspondant au moment où l'état {\tt s} commence (\ie la mesure d'interaction donne la valeur {\tt v$_{sb}$}), suivies de toutes les occurrences de l'évènement {\tt e}, sans qu'il n'y ait eu d'occurrence de l'évènement correspondant au moment où l'état {\tt s} termine (\ie la mesure d'interaction donne la valeur {\tt v$_{se}$}). La fonction ``BoundedWindowIfComplex'' garantie que si {\tt e} est issue d'une séquence d'évènements fenêtrée, cette séquence à commencé après le commencement de l'état {\tt s}
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$During(e,s)$\rrbracket$=
  every Becomes($\llbracket$s$\rrbracket$,v$_{sb}$) $\rightarrow$ 
    every BoundedWindowIfComplex($\llbracket$e$\rrbracket$) 
    and not Becomes($\llbracket$s$\rrbracket$,v$_{se}$)
\end{lstlisting}


{\em During} exprime toutes les occurrences d'un évènement durant une période de temps. E, E$_{sb}$ et E$_{se}$ sont trois évènements où E$_{sb}$ et E$_{se}$ décrivent les évènements de début et de fin d'un état S. L'opérateur signale un évènement chaque fois qu'une occurrence de E se produit pendant l'intervalle démarré par E$_{sb}$ et terminé par E$_{se}$. Formellement:
\begin{equation*}
\begin{split}
\operatorname{During}(E,E_{sb},E_{se})(t)=&(\exists t_1)(\forall t_2)(E_{sb}(t_1)\wedge\\
&\qquad\qquad \thicksim E_{se}(t)\wedge\\
&\qquad\qquad E(t)\wedge \\
&\qquad\qquad (t_1<t)\wedge\\
&\qquad\qquad ((t_1<t_2< t)\rightarrow \thicksim E_{se}(t_2)))
\end{split}
\end{equation*}

%\(During(E,E_{sb},E_{se})(t)=(\exists t_1)(\forall t_2)(E_{sb}(t_1)\wedge \thicksim E_{se}(t)\wedge E(t)\wedge (t_1<t)\wedge ((t_1<t_2< t)\rightarrow \thicksim E_{se}(t_2)))\)\\

\subsection*{Occurs(e,s)}
La compilation de l'opérateur {\em Occurs} est semblable à celle de l'opérateur {\em During} excepté que seule la première occurrence de l'évènement {\tt e} permet à l'opérateur de déclencher un évènement. 
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$Occurs(e,s)$\rrbracket$= 
  every Becomes($\llbracket$s$\rrbracket$,v) $\rightarrow$ 
    BoundedWindowIfComplex($\llbracket$e$\rrbracket$)
    and not Becomes($\llbracket$s$\rrbracket$,v')
\end{lstlisting}
% \begin{lstlisting}[language=EPLPseudoCode]
% $\llbracket$Occurs(F(e),s)$\rrbracket$=
%   every Becomes($\llbracket$s$\rrbracket$,v) $\rightarrow$ 
%   ( every-distinct(location,kind) ($\llbracket$e$\rrbracket$) ) 
%   and not Becomes($\llbracket$s$\rrbracket$,v')
% \end{lstlisting}

% % \begin{lstlisting}[language=EPLPseudoCode]
% % $\llbracket$Occurs(DoDistinct(e),s)$\rrbracket$=
% %   every Becomes($\llbracket$s$\rrbracket$,v) $\rightarrow$ 
% %   ( $\llbracket$e$\rrbracket$ ) 
% %   and not Becomes($\llbracket$s$\rrbracket$,v')
% % \end{lstlisting}
% %lolilol
% \begin{lstlisting}[frame=bt]
% F(X) = match $\llbracket$ X $\rrbracket$ with
%   | [ $\llbracket$Or(E)$\rrbracket$ when (nbLeaf(E)>1) ] $\Mapsto$ 
%                                every Becomes($\llbracket$s$\rrbracket$,v) $\rightarrow$ 
%                                  ( ($\llbracket$e$\rrbracket$) ) 
%                                  and not Becomes($\llbracket$s$\rrbracket$,v')
%   | _ $\Mapsto$ every Becomes($\llbracket$s$\rrbracket$,v) $\rightarrow$ 
%           ( every-distinct(location,kind) ($\llbracket$e$\rrbracket$) ) 
%           and not Becomes($\llbracket$s$\rrbracket$,v')

% rec isOnlyLeaf(E) = match E with
%   | [] $\Mapsto$ true
%   | e::_ when (e != leaf) $\Mapsto$ false
%   | e::E when (e = leaf) $\Mapsto$ isOnlyLeaf(E)
                                     
% \end{lstlisting}

 % [ $\llbracket$Occurs(s$_1$,s$_2$)$\rrbracket$ | $\llbracket$Or(e$_1$, $\dots$ ,e$_n$)$\rrbracket$ ] $\Mapsto$ trees=buildOrTrees
 %                                           replace every by every-distinct(timestamp) 
 %  | $\llbracket$And(e$_1$, $\dots$ ,e$_n$)$\rrbracket$ $\Mapsto$ trees=buildAndTrees
 %                         replace every by every-distinct(timestamp) 
 %  | [ e ] $\Mapsto$ trees=replace every by every-distinct(timestamp) 
{\em Occurs} exprime la première occurrence d'un évènement durant une période de temps. E, E$_{sb}$ et E$_{se}$ sont trois évènements où E$_{sb}$ et E$_{se}$ décrivent les évènements de début et de fin d'un état S. L'opérateur signale un évènement à la première occurrence de E qui se produit pendant l'intervalle démarré par E$_{sb}$ et terminé par E$_{se}$. Donc l'instant auquel se produit E$_{sb}$ est inférieur à l'instant auquel se produit E, et il n'existe pas d'instant entre E$_{sb}$ et E auquel se produit E$_{se}$. Formellement:
\begin{equation*}
\begin{split}
\operatorname{Occurs}(E,E_{sb},E_{se})(t)=&(\exists t_1)(\forall t_2)(E_{sb}(t_1)\wedge\\
&\qquad\qquad  E(t)\wedge\\
&\qquad\qquad \thicksim E_{se}(t)\wedge\\
&\qquad\qquad (t_1<t) \wedge\\
&\qquad\qquad ((t_1<t_2<t)\rightarrow \thicksim E_{se}(t_2) \vee \thicksim E(t_2)))
\end{split}
\end{equation*}

%\(Occurs(E,E_{sb},E_{se})(t)=(\exists t_1)(\forall t_2)(E_{sb}(t_1)\wedge E(t)\wedge (t_1<t)\wedge ((t_1<t_2<t)\rightarrow \thicksim E_{se}(t_2) \vee \thicksim E(t_2)))\)

\subsection*{Occurs(s$_1$,s$_2$)}
% \begin{lstlisting}[language=EPLPseudoCode]
% $\llbracket$Occurs(s$_1$,s$_2$)$\rrbracket$=
%   ((Becomes($\llbracket$s$_1$$\rrbracket$,v) $\rightarrow$ 
%     every-distinct(timestamp) Becomes($\llbracket$s$_2$$\rrbracket$,v) 
%     and not Becomes($\llbracket$s$_1$$\rrbracket$,v'))
%   or 
%   (Becomes($\llbracket$s$_2$$\rrbracket$,v) $\rightarrow$ 
%     every-distinct(timestamp) Becomes($\llbracket$s$_1$$\rrbracket$,v)
%     and not Becomes($\llbracket$s$_2$$\rrbracket$,v')))
% \end{lstlisting}
L'opérateur {\em Occurs} prenant deux état en argument, est une disjonction de la version qui prend un évènement et un état en argument. Pour que l'opérateur déclenche un évènement, une occurrence de l'évènement de début de l'état {\tt s$_2$} doit se produire durant l'état {\tt s$_1$} ou, une occurrence de l'évènement de début de l'état {\tt s$_1$} doit se produire durant l'état {\tt s$_2$}
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$Occurs(s$_1$,s$_2$)$\rrbracket$=
  every Occurs(Becomes($\llbracket$s$_2$$\rrbracket$,v),$\llbracket$s$_1\rrbracket$)
  or 
  every Occurs(Becomes($\llbracket$s$_1$$\rrbracket$,v),$\llbracket$s$_2\rrbracket$)
\end{lstlisting}

Cette version de l'opérateur {\em Occurs} exprime la superposition partielle de périodes de temps. Il s'agit d'une disjonction de deux évènements {\em Occurs:$\mathds{E}\times\mathds{E}\times\mathds{E}\rightarrow \mathds{E}$}.
E$_{s_{1}b}$, E$_{s_{1}e}$, E$_{s_{2}b}$ et E$_{s_{2}e}$ sont des évènement où E$_{s_{1}b}$ et E$_{s_{1}e}$ sont les évènements de début et de fin d'un état S$_1$ et où E$_{s_{2}b}$ et E$_{s_{2}e}$ sont les évènements de début et de fin d'un état S$_2$. 
\begin{equation*}
\begin{split}
\operatorname{Occurs}(E_{s_{1}b},E_{s_{1}e},E_{s_{2}b},E_{s_{2}e})(t)=&Occurs(E_{s_{2}b},E_{s_{1}b},E_{s_{1}e})(t)\vee\\
& Occurs(E_{s_{1}b},E_{s_{2}b},E_{s_{2}e})(t)
\end{split}
\end{equation*}

% \(Occurs(E_{s_{1}b},E_{s_{1}2},E_{s_{2}b},E_{s_{2}e})(t)=(\exists t_1)(\forall t_2)((E_{s_{1}b}(t_1)\wedge E_{s_{2}b}(t)\wedge ((t_1<t_2<t)\rightarrow \thicksim E_{s_{1}e}(t_2)) \wedge ((t_1<t_2<t)\rightarrow \thicksim E_{s_{2}b}(t_2)))\vee (E_{s_{2}b}(t_1)\wedge E_{s_{1}b}(t)\wedge ((t_1<t_2<t)\rightarrow \thicksim E_{s_{2}e}(t_2)) \wedge ((t_1<t_2<t)\rightarrow \thicksim E_{s_{1}b}(t_2)))  \wedge (t_1<t))\)

% \(Occurs(E_{s_{1}b},E_{s_{1}e},E_{s_{2}b},E_{s_{2}e})(t)=Occurs(E_{s_{2}b},E_{s_{1}b},E_{s_{1}e})(t)\vee Occurs(E_{s_{1}b},E_{s_{2}b},E_{s_{2}e})(t) \)


\subsection*{Overlapping(s$_1$,s$_2$)}
La séquence d'évènements de l'opérateur {\em Overlapping} reconnaît toutes les occurrence de l'évènement de début de {\tt s$_1$} suivit d'une occurrence de l'évènement de début de {\tt s$_1$}, sans qu'il n'y ait eu d'occurrence de fin de {\tt s$_1$}, suivit d'une occurrence de fin de {\tt s$_1$}, sans qu'il n'y ait eu d'occurrence de fin de {\tt s$_2$}
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$ Overlapping(s$_1$,s$_2$) $\rrbracket$ = 
  every Becomes( $\llbracket$ s $_1$ $\rrbracket$,v$_{s_{1}b}$) $\rightarrow$ 
    Becomes($\llbracket$s$_2$ $\rrbracket$,v$_{s_{2}b}$) 
    and not Becomes($\llbracket$s$_1$ $\rrbracket$,v$_{s_{1}e}$) $\rightarrow$ 
      Becomes($\llbracket$s$_1$ $\rrbracket$,v$_{s_{1}e}$) 
      and not Becomes($\llbracket$ s$_2$ $\rrbracket$,v$_{s_{2}e}$) 
\end{lstlisting}

{\em Overlapping} décrit le chevauchement de deux séquences. E$_{s_{1}b}$, E$_{s_{1}e}$, E$_{s_{2}b}$ et E$_{s_{2}e}$ sont des évènement où E$_{s_{1}b}$ et E$_{s_{1}e}$ sont les évènements de début et de fin d'un état S$_1$ et où E$_{s_{2}b}$ et E$_{s_{2}e}$ sont les évènements de début et de fin d'un état S$_2$. Cet opérateur signale un évènement lorsqu'une occurrence de E$_{s_{1}b}$ est suivit d'une occurrence de E$_{s_{2}b}$ elle même suivie d'une occurrence de E$_{s_{1}e}$. Donc l'instant auquel se produit E$_{s_{1}b}$ est inférieur à l'instant auquel se produit E$_{s_{2}b}$, qui est inférieur à l'instant auquel se produit E$_{s_{1}e}$. De plus il n'existe pas d'instant entre E$_{s_{1}b}$ et E$_{s_{2}b}$ auquel se produit E$_{s_{1}e}$ et il n'existe pas d'instant entre E$_{s_{2}b}$ et E$_{s_{1}e}$ auquel se produit E$_{s_{2}e}$. Formellement:
\begin{equation*}
\begin{split}
\operatorname{Overlapping}(E_{s_{1}b},E_{s_{1}e},E_{s_{2}b},E_{s_{2}e})(t)=&(\exists t_1)(\exists t_2)(\forall t_3)\\
&\qquad (E_{s_{1}b}(t_1)\wedge\\
&\qquad \thicksim E_{s_{1}e}(t_2)\wedge\\
&\qquad E_{s_{2}b}(t_2)\wedge\\
&\qquad \thicksim E_{s_{2}e}(t) \wedge\\
&\qquad E_{s_{1}e}(t)\wedge\\
&\qquad (t_1<t_2<t)\wedge \\
&\qquad ((t_1<t_3\leq t_2)\rightarrow \thicksim E_{s_{1}e}(t_3)) \wedge \\
&\qquad\qquad((t_2<t_3\leq t)\rightarrow \thicksim E_{s_{2}e}(t_3)))
\end{split}
\end{equation*}


% \(Overlapping(E_{s_{1}b},E_{s_{1}e},E_{s_{2}b},E_{s_{2}e})(t)=(\exists t_1)(\exists t_2)(\forall t_3)(E_{s_{1}b}(t1)\wedge \thicksim E_{s_{1}e}(t_2)\wedge E_{s_{2}b}(t2)\wedge \thicksim E_{s_{2}e}(t) \wedge E_{s_{1}e}(t)\wedge (t_1<t_2<t)\wedge ((t_1<t_3\leq t_2)\rightarrow \thicksim E_{s_{1}e}(t_3)) \wedge ((t_2<t_3\leq t)\rightarrow \thicksim E_{s_{2}e}(t_3))) \)

\subsection*{And(e$_0$,$\dots$,e$_n$)}
Pour que l'opérateur {\tt And} déclenche un évènement, il faut qu'une occurrence de chaque évènement qu'il prend en argument se soit produit.
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$And(e$_1$, $\dots$ ,e$_n$)$\rrbracket$=
  WindowIfComplex($\llbracket$e$_1$$\rrbracket$) and $\dots$ and WindowIfComplex($\llbracket$e$_n$$\rrbracket$)
\end{lstlisting}

{\em And} exprime la conjonction d'un ensemble d'évènements {E$_1$,$\dots$,E$_n$}. L'opérateur signale un évènement lorsque une occurrence de chaque évènement E$_i$ s'est produit. Il n'existe d'instant pour une occurrence d'évènement correspondant au dernier évènement reconnu (l'évènement déclencheur de l'opérateur) qui précède l'instant de l'occurrence de du dernier évènement reconnu. Formellement: 
\begin{equation*}
\begin{split}
\operatorname{And}(E_1, \dots , E_n)(t)=&(\exists t_{i=1;n})(\exists i_0)(\forall t')\\
&\qquad\qquad(E_1(t_1)\underset{i}\wedge\\
&\qquad\qquad E_i(t_i) \wedge \\
&\qquad\qquad E_n(t_n)\wedge \\
&\qquad\qquad (t_1\leq t)\underset{i}\wedge \\
&\qquad\qquad (t_i\leq t) \wedge \\
&\qquad\qquad (t_n\leq t)\wedge \\
&\qquad\qquad(t_{i_0}=t) \wedge\\
&\qquad\qquad ((t'<t)\rightarrow \thicksim E_{i_0}(t')))
\end{split}
\end{equation*}


%\(And(E_1, \dots , E_n)(t)=(\exists t_{i=1;n})(\exists i_0)(\forall t')(E_1(t_1)\underset{i}\wedge E_i(t_i) \wedge E_n(t_n)\wedge (t_1\leq t)\underset{i}\wedge (t_i\leq t) \wedge (t_n\leq t)\wedge (t_{i_0}=t) \wedge ((t'<t)\rightarrow \thicksim E_{i_0}(t')))\)

\subsection*{Or(e$_0$,$\dots$,e$_n$)}
% add window if complex or EveryIfLeaf
\begin{lstlisting}[language=EPLPseudoCode]
$\llbracket$Or(e$_1$, $\dots$ ,e$_n$)$\rrbracket$=
  every $\llbracket$e$_1$$\rrbracket$ or $\dots$ or every $\llbracket$e$_n$$\rrbracket$
\end{lstlisting}

{\em Or} exprime la disjonction d'un ensemble d'évènements {E$_1$,$\dots$,E$_n$}. L'opérateur signale un évènement quand un évènement de cet ensemble se produit. Formellement:
\begin{equation*}
\begin{split}
\operatorname{Or}(E_1, \dots , E_n)(t)=E_1(t)\vee \dots \vee E_n(t)
\end{split}
\end{equation*}
%\(Or(E_0, \dots , E_n)(t)=E_0(t)\vee \dots \vee E_n(t)\)

%\end{figure}